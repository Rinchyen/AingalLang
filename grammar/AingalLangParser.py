# Generated from AingalLangParser.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,73,517,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,1,0,1,0,4,0,89,8,0,11,0,12,0,90,1,
        0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,108,
        8,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3,2,120,8,2,1,3,3,3,
        123,8,3,1,3,1,3,3,3,127,8,3,1,3,1,3,1,3,3,3,132,8,3,1,4,1,4,1,4,
        1,4,1,5,3,5,139,8,5,1,5,1,5,3,5,143,8,5,1,6,1,6,3,6,147,8,6,1,7,
        1,7,1,7,1,7,5,7,153,8,7,10,7,12,7,156,9,7,1,7,1,7,1,8,1,8,1,8,5,
        8,163,8,8,10,8,12,8,166,9,8,1,9,1,9,1,10,1,10,1,10,5,10,173,8,10,
        10,10,12,10,176,9,10,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,
        1,11,1,11,1,11,1,11,1,11,3,11,192,8,11,1,12,1,12,4,12,196,8,12,11,
        12,12,12,197,1,12,1,12,1,13,1,13,1,14,1,14,1,14,1,14,3,14,208,8,
        14,1,14,1,14,1,14,1,14,1,15,1,15,1,15,5,15,217,8,15,10,15,12,15,
        220,9,15,1,16,1,16,3,16,224,8,16,1,17,1,17,1,17,1,18,3,18,230,8,
        18,1,18,1,18,1,18,3,18,235,8,18,1,18,1,18,1,19,1,19,1,19,5,19,242,
        8,19,10,19,12,19,245,9,19,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,
        1,20,1,20,1,20,1,20,3,20,259,8,20,1,21,1,21,1,21,1,21,1,21,1,21,
        3,21,267,8,21,1,21,1,21,1,21,1,21,1,21,1,21,3,21,275,8,21,5,21,277,
        8,21,10,21,12,21,280,9,21,1,21,1,21,1,21,3,21,285,8,21,3,21,287,
        8,21,1,22,1,22,1,22,1,22,1,22,1,22,4,22,295,8,22,11,22,12,22,296,
        1,22,1,22,1,22,3,22,302,8,22,1,22,1,22,1,22,1,22,1,22,1,22,4,22,
        310,8,22,11,22,12,22,311,1,22,1,22,1,22,3,22,317,8,22,5,22,319,8,
        22,10,22,12,22,322,9,22,1,22,1,22,1,22,4,22,327,8,22,11,22,12,22,
        328,1,22,1,22,1,22,3,22,334,8,22,3,22,336,8,22,1,23,1,23,3,23,340,
        8,23,1,24,1,24,1,24,3,24,345,8,24,1,24,1,24,1,24,1,24,1,24,1,24,
        1,24,1,25,1,25,3,25,356,8,25,1,26,1,26,1,26,3,26,361,8,26,1,27,1,
        27,4,27,365,8,27,11,27,12,27,366,1,27,1,27,1,27,3,27,372,8,27,1,
        28,1,28,1,28,1,28,1,28,1,28,4,28,380,8,28,11,28,12,28,381,1,28,1,
        28,1,28,3,28,387,8,28,1,29,1,29,1,29,1,29,5,29,393,8,29,10,29,12,
        29,396,9,29,1,30,1,30,5,30,400,8,30,10,30,12,30,403,9,30,1,30,1,
        30,1,31,1,31,1,31,1,31,1,31,1,31,5,31,413,8,31,10,31,12,31,416,9,
        31,1,32,1,32,1,32,1,32,1,32,1,32,5,32,424,8,32,10,32,12,32,427,9,
        32,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,
        33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,3,33,450,8,33,1,34,1,
        34,1,34,3,34,455,8,34,1,35,1,35,3,35,459,8,35,1,36,1,36,3,36,463,
        8,36,1,36,1,36,1,36,1,36,3,36,469,8,36,1,37,1,37,1,38,1,38,1,38,
        5,38,476,8,38,10,38,12,38,479,9,38,1,39,1,39,1,39,5,39,484,8,39,
        10,39,12,39,487,9,39,1,40,1,40,1,40,3,40,492,8,40,1,41,1,41,1,41,
        1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,
        1,41,1,41,1,41,3,41,513,8,41,1,42,1,42,1,42,0,2,62,64,43,0,2,4,6,
        8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,
        52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,0,10,2,0,56,56,
        71,71,2,0,57,57,71,71,1,0,58,62,1,0,67,70,1,0,25,26,1,0,27,29,1,
        0,37,38,2,0,35,36,39,40,2,0,30,30,41,41,2,0,30,34,41,41,572,0,86,
        1,0,0,0,2,107,1,0,0,0,4,119,1,0,0,0,6,122,1,0,0,0,8,133,1,0,0,0,
        10,138,1,0,0,0,12,146,1,0,0,0,14,148,1,0,0,0,16,159,1,0,0,0,18,167,
        1,0,0,0,20,169,1,0,0,0,22,191,1,0,0,0,24,195,1,0,0,0,26,201,1,0,
        0,0,28,203,1,0,0,0,30,213,1,0,0,0,32,221,1,0,0,0,34,225,1,0,0,0,
        36,229,1,0,0,0,38,238,1,0,0,0,40,258,1,0,0,0,42,260,1,0,0,0,44,288,
        1,0,0,0,46,339,1,0,0,0,48,341,1,0,0,0,50,355,1,0,0,0,52,360,1,0,
        0,0,54,371,1,0,0,0,56,373,1,0,0,0,58,388,1,0,0,0,60,397,1,0,0,0,
        62,406,1,0,0,0,64,417,1,0,0,0,66,449,1,0,0,0,68,451,1,0,0,0,70,458,
        1,0,0,0,72,462,1,0,0,0,74,470,1,0,0,0,76,472,1,0,0,0,78,480,1,0,
        0,0,80,491,1,0,0,0,82,512,1,0,0,0,84,514,1,0,0,0,86,88,5,1,0,0,87,
        89,3,2,1,0,88,87,1,0,0,0,89,90,1,0,0,0,90,88,1,0,0,0,90,91,1,0,0,
        0,91,92,1,0,0,0,92,93,5,2,0,0,93,1,1,0,0,0,94,108,3,6,3,0,95,108,
        3,8,4,0,96,108,3,72,36,0,97,108,3,28,14,0,98,108,3,36,18,0,99,108,
        3,34,17,0,100,108,3,58,29,0,101,108,3,42,21,0,102,108,3,46,23,0,
        103,108,3,48,24,0,104,108,3,56,28,0,105,108,3,60,30,0,106,108,3,
        68,34,0,107,94,1,0,0,0,107,95,1,0,0,0,107,96,1,0,0,0,107,97,1,0,
        0,0,107,98,1,0,0,0,107,99,1,0,0,0,107,100,1,0,0,0,107,101,1,0,0,
        0,107,102,1,0,0,0,107,103,1,0,0,0,107,104,1,0,0,0,107,105,1,0,0,
        0,107,106,1,0,0,0,108,3,1,0,0,0,109,120,3,46,23,0,110,120,3,8,4,
        0,111,120,3,6,3,0,112,120,3,72,36,0,113,120,3,28,14,0,114,120,3,
        34,17,0,115,120,3,42,21,0,116,120,3,60,30,0,117,120,5,18,0,0,118,
        120,3,58,29,0,119,109,1,0,0,0,119,110,1,0,0,0,119,111,1,0,0,0,119,
        112,1,0,0,0,119,113,1,0,0,0,119,114,1,0,0,0,119,115,1,0,0,0,119,
        116,1,0,0,0,119,117,1,0,0,0,119,118,1,0,0,0,120,5,1,0,0,0,121,123,
        5,7,0,0,122,121,1,0,0,0,122,123,1,0,0,0,123,126,1,0,0,0,124,127,
        3,24,12,0,125,127,3,70,35,0,126,124,1,0,0,0,126,125,1,0,0,0,127,
        128,1,0,0,0,128,129,5,8,0,0,129,131,3,22,11,0,130,132,3,26,13,0,
        131,130,1,0,0,0,131,132,1,0,0,0,132,7,1,0,0,0,133,134,3,24,12,0,
        134,135,5,8,0,0,135,136,3,22,11,0,136,9,1,0,0,0,137,139,5,21,0,0,
        138,137,1,0,0,0,138,139,1,0,0,0,139,140,1,0,0,0,140,142,3,12,6,0,
        141,143,5,22,0,0,142,141,1,0,0,0,142,143,1,0,0,0,143,11,1,0,0,0,
        144,147,5,71,0,0,145,147,3,14,7,0,146,144,1,0,0,0,146,145,1,0,0,
        0,147,13,1,0,0,0,148,149,5,50,0,0,149,154,3,16,8,0,150,151,5,45,
        0,0,151,153,3,16,8,0,152,150,1,0,0,0,153,156,1,0,0,0,154,152,1,0,
        0,0,154,155,1,0,0,0,155,157,1,0,0,0,156,154,1,0,0,0,157,158,5,51,
        0,0,158,15,1,0,0,0,159,164,3,18,9,0,160,161,5,46,0,0,161,163,3,18,
        9,0,162,160,1,0,0,0,163,166,1,0,0,0,164,162,1,0,0,0,164,165,1,0,
        0,0,165,17,1,0,0,0,166,164,1,0,0,0,167,168,7,0,0,0,168,19,1,0,0,
        0,169,174,7,1,0,0,170,171,5,25,0,0,171,173,7,1,0,0,172,170,1,0,0,
        0,173,176,1,0,0,0,174,172,1,0,0,0,174,175,1,0,0,0,175,21,1,0,0,0,
        176,174,1,0,0,0,177,192,3,36,18,0,178,192,3,40,20,0,179,192,3,62,
        31,0,180,192,3,74,37,0,181,192,3,10,5,0,182,192,3,20,10,0,183,192,
        5,56,0,0,184,192,5,57,0,0,185,192,3,24,12,0,186,192,5,71,0,0,187,
        188,5,54,0,0,188,189,3,22,11,0,189,190,5,55,0,0,190,192,1,0,0,0,
        191,177,1,0,0,0,191,178,1,0,0,0,191,179,1,0,0,0,191,180,1,0,0,0,
        191,181,1,0,0,0,191,182,1,0,0,0,191,183,1,0,0,0,191,184,1,0,0,0,
        191,185,1,0,0,0,191,186,1,0,0,0,191,187,1,0,0,0,192,23,1,0,0,0,193,
        194,5,23,0,0,194,196,5,24,0,0,195,193,1,0,0,0,196,197,1,0,0,0,197,
        195,1,0,0,0,197,198,1,0,0,0,198,199,1,0,0,0,199,200,5,71,0,0,200,
        25,1,0,0,0,201,202,7,2,0,0,202,27,1,0,0,0,203,204,5,3,0,0,204,205,
        5,71,0,0,205,207,5,54,0,0,206,208,3,30,15,0,207,206,1,0,0,0,207,
        208,1,0,0,0,208,209,1,0,0,0,209,210,5,55,0,0,210,211,3,60,30,0,211,
        212,5,4,0,0,212,29,1,0,0,0,213,218,3,32,16,0,214,215,5,46,0,0,215,
        217,3,32,16,0,216,214,1,0,0,0,217,220,1,0,0,0,218,216,1,0,0,0,218,
        219,1,0,0,0,219,31,1,0,0,0,220,218,1,0,0,0,221,223,5,71,0,0,222,
        224,3,26,13,0,223,222,1,0,0,0,223,224,1,0,0,0,224,33,1,0,0,0,225,
        226,5,5,0,0,226,227,3,22,11,0,227,35,1,0,0,0,228,230,5,6,0,0,229,
        228,1,0,0,0,229,230,1,0,0,0,230,231,1,0,0,0,231,232,5,71,0,0,232,
        234,5,54,0,0,233,235,3,38,19,0,234,233,1,0,0,0,234,235,1,0,0,0,235,
        236,1,0,0,0,236,237,5,55,0,0,237,37,1,0,0,0,238,243,3,22,11,0,239,
        240,5,46,0,0,240,242,3,22,11,0,241,239,1,0,0,0,242,245,1,0,0,0,243,
        241,1,0,0,0,243,244,1,0,0,0,244,39,1,0,0,0,245,243,1,0,0,0,246,247,
        5,66,0,0,247,248,5,54,0,0,248,249,3,62,31,0,249,250,5,46,0,0,250,
        251,3,62,31,0,251,252,5,55,0,0,252,259,1,0,0,0,253,254,7,3,0,0,254,
        255,5,54,0,0,255,256,3,62,31,0,256,257,5,55,0,0,257,259,1,0,0,0,
        258,246,1,0,0,0,258,253,1,0,0,0,259,41,1,0,0,0,260,261,5,10,0,0,
        261,262,5,54,0,0,262,263,3,74,37,0,263,266,5,55,0,0,264,267,3,2,
        1,0,265,267,3,60,30,0,266,264,1,0,0,0,266,265,1,0,0,0,267,278,1,
        0,0,0,268,269,5,11,0,0,269,270,5,54,0,0,270,271,3,74,37,0,271,274,
        5,55,0,0,272,275,3,2,1,0,273,275,3,60,30,0,274,272,1,0,0,0,274,273,
        1,0,0,0,275,277,1,0,0,0,276,268,1,0,0,0,277,280,1,0,0,0,278,276,
        1,0,0,0,278,279,1,0,0,0,279,286,1,0,0,0,280,278,1,0,0,0,281,284,
        5,12,0,0,282,285,3,2,1,0,283,285,3,60,30,0,284,282,1,0,0,0,284,283,
        1,0,0,0,285,287,1,0,0,0,286,281,1,0,0,0,286,287,1,0,0,0,287,43,1,
        0,0,0,288,289,5,10,0,0,289,290,5,54,0,0,290,291,3,74,37,0,291,301,
        5,55,0,0,292,294,5,52,0,0,293,295,3,4,2,0,294,293,1,0,0,0,295,296,
        1,0,0,0,296,294,1,0,0,0,296,297,1,0,0,0,297,298,1,0,0,0,298,299,
        5,53,0,0,299,302,1,0,0,0,300,302,3,2,1,0,301,292,1,0,0,0,301,300,
        1,0,0,0,302,320,1,0,0,0,303,304,5,11,0,0,304,305,5,54,0,0,305,306,
        3,74,37,0,306,316,5,55,0,0,307,309,5,52,0,0,308,310,3,4,2,0,309,
        308,1,0,0,0,310,311,1,0,0,0,311,309,1,0,0,0,311,312,1,0,0,0,312,
        313,1,0,0,0,313,314,5,53,0,0,314,317,1,0,0,0,315,317,3,2,1,0,316,
        307,1,0,0,0,316,315,1,0,0,0,317,319,1,0,0,0,318,303,1,0,0,0,319,
        322,1,0,0,0,320,318,1,0,0,0,320,321,1,0,0,0,321,335,1,0,0,0,322,
        320,1,0,0,0,323,333,5,12,0,0,324,326,5,52,0,0,325,327,3,4,2,0,326,
        325,1,0,0,0,327,328,1,0,0,0,328,326,1,0,0,0,328,329,1,0,0,0,329,
        330,1,0,0,0,330,331,5,53,0,0,331,334,1,0,0,0,332,334,3,2,1,0,333,
        324,1,0,0,0,333,332,1,0,0,0,334,336,1,0,0,0,335,323,1,0,0,0,335,
        336,1,0,0,0,336,45,1,0,0,0,337,340,3,48,24,0,338,340,3,56,28,0,339,
        337,1,0,0,0,339,338,1,0,0,0,340,47,1,0,0,0,341,342,5,14,0,0,342,
        344,5,54,0,0,343,345,3,50,25,0,344,343,1,0,0,0,344,345,1,0,0,0,345,
        346,1,0,0,0,346,347,5,45,0,0,347,348,3,74,37,0,348,349,5,45,0,0,
        349,350,3,52,26,0,350,351,5,55,0,0,351,352,3,54,27,0,352,49,1,0,
        0,0,353,356,5,71,0,0,354,356,3,6,3,0,355,353,1,0,0,0,355,354,1,0,
        0,0,356,51,1,0,0,0,357,361,3,6,3,0,358,361,3,72,36,0,359,361,3,68,
        34,0,360,357,1,0,0,0,360,358,1,0,0,0,360,359,1,0,0,0,361,53,1,0,
        0,0,362,364,5,52,0,0,363,365,3,4,2,0,364,363,1,0,0,0,365,366,1,0,
        0,0,366,364,1,0,0,0,366,367,1,0,0,0,367,368,1,0,0,0,368,369,5,53,
        0,0,369,372,1,0,0,0,370,372,3,2,1,0,371,362,1,0,0,0,371,370,1,0,
        0,0,372,55,1,0,0,0,373,374,5,19,0,0,374,375,5,54,0,0,375,376,3,74,
        37,0,376,386,5,55,0,0,377,379,5,52,0,0,378,380,3,4,2,0,379,378,1,
        0,0,0,380,381,1,0,0,0,381,379,1,0,0,0,381,382,1,0,0,0,382,383,1,
        0,0,0,383,384,5,53,0,0,384,387,1,0,0,0,385,387,3,2,1,0,386,377,1,
        0,0,0,386,385,1,0,0,0,387,57,1,0,0,0,388,389,5,9,0,0,389,394,3,22,
        11,0,390,391,5,46,0,0,391,393,3,22,11,0,392,390,1,0,0,0,393,396,
        1,0,0,0,394,392,1,0,0,0,394,395,1,0,0,0,395,59,1,0,0,0,396,394,1,
        0,0,0,397,401,5,52,0,0,398,400,3,2,1,0,399,398,1,0,0,0,400,403,1,
        0,0,0,401,399,1,0,0,0,401,402,1,0,0,0,402,404,1,0,0,0,403,401,1,
        0,0,0,404,405,5,53,0,0,405,61,1,0,0,0,406,407,6,31,-1,0,407,408,
        3,64,32,0,408,414,1,0,0,0,409,410,10,2,0,0,410,411,7,4,0,0,411,413,
        3,64,32,0,412,409,1,0,0,0,413,416,1,0,0,0,414,412,1,0,0,0,414,415,
        1,0,0,0,415,63,1,0,0,0,416,414,1,0,0,0,417,418,6,32,-1,0,418,419,
        3,66,33,0,419,425,1,0,0,0,420,421,10,2,0,0,421,422,7,5,0,0,422,424,
        3,66,33,0,423,420,1,0,0,0,424,427,1,0,0,0,425,423,1,0,0,0,425,426,
        1,0,0,0,426,65,1,0,0,0,427,425,1,0,0,0,428,429,5,25,0,0,429,450,
        3,66,33,0,430,431,5,26,0,0,431,450,3,66,33,0,432,450,3,36,18,0,433,
        450,5,56,0,0,434,450,3,24,12,0,435,450,5,71,0,0,436,450,5,57,0,0,
        437,450,3,68,34,0,438,439,5,54,0,0,439,440,3,62,31,0,440,441,5,55,
        0,0,441,450,1,0,0,0,442,443,5,54,0,0,443,444,3,26,13,0,444,445,5,
        55,0,0,445,446,3,66,33,0,446,450,1,0,0,0,447,450,5,64,0,0,448,450,
        5,65,0,0,449,428,1,0,0,0,449,430,1,0,0,0,449,432,1,0,0,0,449,433,
        1,0,0,0,449,434,1,0,0,0,449,435,1,0,0,0,449,436,1,0,0,0,449,437,
        1,0,0,0,449,438,1,0,0,0,449,442,1,0,0,0,449,447,1,0,0,0,449,448,
        1,0,0,0,450,67,1,0,0,0,451,452,5,71,0,0,452,454,7,6,0,0,453,455,
        5,45,0,0,454,453,1,0,0,0,454,455,1,0,0,0,455,69,1,0,0,0,456,459,
        5,71,0,0,457,459,3,24,12,0,458,456,1,0,0,0,458,457,1,0,0,0,459,71,
        1,0,0,0,460,463,3,24,12,0,461,463,3,70,35,0,462,460,1,0,0,0,462,
        461,1,0,0,0,463,464,1,0,0,0,464,465,7,7,0,0,465,466,3,22,11,0,466,
        468,1,0,0,0,467,469,5,45,0,0,468,467,1,0,0,0,468,469,1,0,0,0,469,
        73,1,0,0,0,470,471,3,76,38,0,471,75,1,0,0,0,472,477,3,78,39,0,473,
        474,5,43,0,0,474,476,3,78,39,0,475,473,1,0,0,0,476,479,1,0,0,0,477,
        475,1,0,0,0,477,478,1,0,0,0,478,77,1,0,0,0,479,477,1,0,0,0,480,485,
        3,80,40,0,481,482,5,42,0,0,482,484,3,80,40,0,483,481,1,0,0,0,484,
        487,1,0,0,0,485,483,1,0,0,0,485,486,1,0,0,0,486,79,1,0,0,0,487,485,
        1,0,0,0,488,489,5,44,0,0,489,492,3,80,40,0,490,492,3,82,41,0,491,
        488,1,0,0,0,491,490,1,0,0,0,492,81,1,0,0,0,493,494,3,62,31,0,494,
        495,3,84,42,0,495,496,3,62,31,0,496,513,1,0,0,0,497,498,3,20,10,
        0,498,499,7,8,0,0,499,500,3,20,10,0,500,513,1,0,0,0,501,502,3,10,
        5,0,502,503,7,8,0,0,503,504,3,10,5,0,504,513,1,0,0,0,505,506,5,54,
        0,0,506,507,3,74,37,0,507,508,5,55,0,0,508,513,1,0,0,0,509,513,5,
        64,0,0,510,513,5,65,0,0,511,513,5,71,0,0,512,493,1,0,0,0,512,497,
        1,0,0,0,512,501,1,0,0,0,512,505,1,0,0,0,512,509,1,0,0,0,512,510,
        1,0,0,0,512,511,1,0,0,0,513,83,1,0,0,0,514,515,7,9,0,0,515,85,1,
        0,0,0,55,90,107,119,122,126,131,138,142,146,154,164,174,191,197,
        207,218,223,229,234,243,258,266,274,278,284,286,296,301,311,316,
        320,328,333,335,339,344,355,360,366,371,381,386,394,401,414,425,
        449,454,458,462,468,477,485,491,512
    ]

class AingalLangParser ( Parser ):

    grammarFileName = "AingalLangParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'Start Program'", "'End Program'", "'Define Function'", 
                     "'End Function'", "'Return'", "'Call'", "'Set'", "'to'", 
                     "'Display'", "'If'", "'Else If'", "'Else'", "'End If'", 
                     "'For'", "'from'", "'in'", "'End For'", "'break'", 
                     "'While'", "'End While'", "'invert'", "''T'", "'parent'", 
                     "'::'", "'+'", "'-'", "'*'", "'/'", "'%'", "'=='", 
                     "'>'", "'<'", "'>='", "'<='", "'+='", "'-='", "'++'", 
                     "'--'", "'*='", "'/='", "'!='", "'and'", "'or'", "'not'", 
                     "';'", "','", "':'", "'.'", "'\"'", "'['", "']'", "'{'", 
                     "'}'", "'('", "')'", "<INVALID>", "<INVALID>", "'int'", 
                     "'string'", "'bool'", "'float'", "'matrix'", "'void'", 
                     "'true'", "'false'", "'pow'", "'sin'", "'cos'", "'tan'", 
                     "'ctan'" ]

    symbolicNames = [ "<INVALID>", "START_PROGRAM", "END_PROGRAM", "DEFINE_FUNCTION", 
                      "END_FUNCTION", "RETURN", "CALL", "SET", "TO", "DISPLAY", 
                      "IF", "ELSE_IF", "ELSE", "END_IF", "FOR", "FROM", 
                      "IN", "END_FOR", "BREAK", "WHILE", "END_WHILE", "INVERT_MATRIX", 
                      "TRANSPOSITION", "PARENT_SCOPE", "DCOLON", "PLUS", 
                      "MINUS", "MULTIPLY", "DIVIDED_BY", "MODULO", "EQUALS", 
                      "GREATER_THAN", "LESS_THAN", "GREATER_EQUAL", "LESS_EQUAL", 
                      "ADD_TO", "SUBTRACT_FROM", "INCREMENT", "DECREMENT", 
                      "TIMES", "DIVIDE_FROM", "NOT_EQUALS", "AND", "OR", 
                      "NOT", "SEMICOLON", "COMMA", "COLON", "DOT", "QUOTE", 
                      "LBRACK", "RBRACK", "LBRACE", "RBRACE", "LPAREN", 
                      "RPAREN", "NUMBER", "STRING", "TYPE_INT", "TYPE_STRING", 
                      "TYPE_BOOL", "TYPE_FLOAT", "TYPE_MATRIX", "TYPE_VOID", 
                      "TRUE_VALUE", "FALSE_VALUE", "POWER_FUNC", "SIN_FUNC", 
                      "COS_FUNC", "TAN_FUNC", "CTAN_FUNC", "IDENTIFIER", 
                      "WS", "COMMENT" ]

    RULE_program = 0
    RULE_statement = 1
    RULE_loopStatements = 2
    RULE_variableDeclaration = 3
    RULE_assignment = 4
    RULE_matrixExpression = 5
    RULE_matrixAtom = 6
    RULE_matrixConstruction = 7
    RULE_row = 8
    RULE_value = 9
    RULE_stringExpression = 10
    RULE_expression = 11
    RULE_scopedIdentifier = 12
    RULE_typeAnnotation = 13
    RULE_functionDeclaration = 14
    RULE_parameter = 15
    RULE_typedParameter = 16
    RULE_returnStatement = 17
    RULE_functionCall = 18
    RULE_argumentList = 19
    RULE_builtInFunctions = 20
    RULE_ifStatement = 21
    RULE_loopIfStatement = 22
    RULE_loopStatement = 23
    RULE_forLoop = 24
    RULE_forInit = 25
    RULE_forUpdate = 26
    RULE_forBody = 27
    RULE_whileLoop = 28
    RULE_displayStatement = 29
    RULE_blockStatement = 30
    RULE_numExpression = 31
    RULE_term = 32
    RULE_factor = 33
    RULE_operation = 34
    RULE_leftHandSide = 35
    RULE_reassignment = 36
    RULE_boolExpression = 37
    RULE_boolOrExpression = 38
    RULE_boolAndExpression = 39
    RULE_boolNotExpression = 40
    RULE_boolPrimary = 41
    RULE_comparisonOp = 42

    ruleNames =  [ "program", "statement", "loopStatements", "variableDeclaration", 
                   "assignment", "matrixExpression", "matrixAtom", "matrixConstruction", 
                   "row", "value", "stringExpression", "expression", "scopedIdentifier", 
                   "typeAnnotation", "functionDeclaration", "parameter", 
                   "typedParameter", "returnStatement", "functionCall", 
                   "argumentList", "builtInFunctions", "ifStatement", "loopIfStatement", 
                   "loopStatement", "forLoop", "forInit", "forUpdate", "forBody", 
                   "whileLoop", "displayStatement", "blockStatement", "numExpression", 
                   "term", "factor", "operation", "leftHandSide", "reassignment", 
                   "boolExpression", "boolOrExpression", "boolAndExpression", 
                   "boolNotExpression", "boolPrimary", "comparisonOp" ]

    EOF = Token.EOF
    START_PROGRAM=1
    END_PROGRAM=2
    DEFINE_FUNCTION=3
    END_FUNCTION=4
    RETURN=5
    CALL=6
    SET=7
    TO=8
    DISPLAY=9
    IF=10
    ELSE_IF=11
    ELSE=12
    END_IF=13
    FOR=14
    FROM=15
    IN=16
    END_FOR=17
    BREAK=18
    WHILE=19
    END_WHILE=20
    INVERT_MATRIX=21
    TRANSPOSITION=22
    PARENT_SCOPE=23
    DCOLON=24
    PLUS=25
    MINUS=26
    MULTIPLY=27
    DIVIDED_BY=28
    MODULO=29
    EQUALS=30
    GREATER_THAN=31
    LESS_THAN=32
    GREATER_EQUAL=33
    LESS_EQUAL=34
    ADD_TO=35
    SUBTRACT_FROM=36
    INCREMENT=37
    DECREMENT=38
    TIMES=39
    DIVIDE_FROM=40
    NOT_EQUALS=41
    AND=42
    OR=43
    NOT=44
    SEMICOLON=45
    COMMA=46
    COLON=47
    DOT=48
    QUOTE=49
    LBRACK=50
    RBRACK=51
    LBRACE=52
    RBRACE=53
    LPAREN=54
    RPAREN=55
    NUMBER=56
    STRING=57
    TYPE_INT=58
    TYPE_STRING=59
    TYPE_BOOL=60
    TYPE_FLOAT=61
    TYPE_MATRIX=62
    TYPE_VOID=63
    TRUE_VALUE=64
    FALSE_VALUE=65
    POWER_FUNC=66
    SIN_FUNC=67
    COS_FUNC=68
    TAN_FUNC=69
    CTAN_FUNC=70
    IDENTIFIER=71
    WS=72
    COMMENT=73

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def START_PROGRAM(self):
            return self.getToken(AingalLangParser.START_PROGRAM, 0)

        def END_PROGRAM(self):
            return self.getToken(AingalLangParser.END_PROGRAM, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.StatementContext,i)


        def getRuleIndex(self):
            return AingalLangParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = AingalLangParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 86
            self.match(AingalLangParser.START_PROGRAM)
            self.state = 88 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 87
                self.statement()
                self.state = 90 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 4503599636301544) != 0) or _la==71):
                    break

            self.state = 92
            self.match(AingalLangParser.END_PROGRAM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclaration(self):
            return self.getTypedRuleContext(AingalLangParser.VariableDeclarationContext,0)


        def assignment(self):
            return self.getTypedRuleContext(AingalLangParser.AssignmentContext,0)


        def reassignment(self):
            return self.getTypedRuleContext(AingalLangParser.ReassignmentContext,0)


        def functionDeclaration(self):
            return self.getTypedRuleContext(AingalLangParser.FunctionDeclarationContext,0)


        def functionCall(self):
            return self.getTypedRuleContext(AingalLangParser.FunctionCallContext,0)


        def returnStatement(self):
            return self.getTypedRuleContext(AingalLangParser.ReturnStatementContext,0)


        def displayStatement(self):
            return self.getTypedRuleContext(AingalLangParser.DisplayStatementContext,0)


        def ifStatement(self):
            return self.getTypedRuleContext(AingalLangParser.IfStatementContext,0)


        def loopStatement(self):
            return self.getTypedRuleContext(AingalLangParser.LoopStatementContext,0)


        def forLoop(self):
            return self.getTypedRuleContext(AingalLangParser.ForLoopContext,0)


        def whileLoop(self):
            return self.getTypedRuleContext(AingalLangParser.WhileLoopContext,0)


        def blockStatement(self):
            return self.getTypedRuleContext(AingalLangParser.BlockStatementContext,0)


        def operation(self):
            return self.getTypedRuleContext(AingalLangParser.OperationContext,0)


        def getRuleIndex(self):
            return AingalLangParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = AingalLangParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.state = 107
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 94
                self.variableDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 95
                self.assignment()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 96
                self.reassignment()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 97
                self.functionDeclaration()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 98
                self.functionCall()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 99
                self.returnStatement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 100
                self.displayStatement()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 101
                self.ifStatement()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 102
                self.loopStatement()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 103
                self.forLoop()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 104
                self.whileLoop()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 105
                self.blockStatement()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 106
                self.operation()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopStatementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loopStatement(self):
            return self.getTypedRuleContext(AingalLangParser.LoopStatementContext,0)


        def assignment(self):
            return self.getTypedRuleContext(AingalLangParser.AssignmentContext,0)


        def variableDeclaration(self):
            return self.getTypedRuleContext(AingalLangParser.VariableDeclarationContext,0)


        def reassignment(self):
            return self.getTypedRuleContext(AingalLangParser.ReassignmentContext,0)


        def functionDeclaration(self):
            return self.getTypedRuleContext(AingalLangParser.FunctionDeclarationContext,0)


        def returnStatement(self):
            return self.getTypedRuleContext(AingalLangParser.ReturnStatementContext,0)


        def ifStatement(self):
            return self.getTypedRuleContext(AingalLangParser.IfStatementContext,0)


        def blockStatement(self):
            return self.getTypedRuleContext(AingalLangParser.BlockStatementContext,0)


        def BREAK(self):
            return self.getToken(AingalLangParser.BREAK, 0)

        def displayStatement(self):
            return self.getTypedRuleContext(AingalLangParser.DisplayStatementContext,0)


        def getRuleIndex(self):
            return AingalLangParser.RULE_loopStatements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopStatements" ):
                listener.enterLoopStatements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopStatements" ):
                listener.exitLoopStatements(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopStatements" ):
                return visitor.visitLoopStatements(self)
            else:
                return visitor.visitChildren(self)




    def loopStatements(self):

        localctx = AingalLangParser.LoopStatementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_loopStatements)
        try:
            self.state = 119
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 109
                self.loopStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 110
                self.assignment()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 111
                self.variableDeclaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 112
                self.reassignment()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 113
                self.functionDeclaration()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 114
                self.returnStatement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 115
                self.ifStatement()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 116
                self.blockStatement()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 117
                self.match(AingalLangParser.BREAK)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 118
                self.displayStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TO(self):
            return self.getToken(AingalLangParser.TO, 0)

        def expression(self):
            return self.getTypedRuleContext(AingalLangParser.ExpressionContext,0)


        def scopedIdentifier(self):
            return self.getTypedRuleContext(AingalLangParser.ScopedIdentifierContext,0)


        def leftHandSide(self):
            return self.getTypedRuleContext(AingalLangParser.LeftHandSideContext,0)


        def SET(self):
            return self.getToken(AingalLangParser.SET, 0)

        def typeAnnotation(self):
            return self.getTypedRuleContext(AingalLangParser.TypeAnnotationContext,0)


        def getRuleIndex(self):
            return AingalLangParser.RULE_variableDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableDeclaration" ):
                listener.enterVariableDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableDeclaration" ):
                listener.exitVariableDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableDeclaration" ):
                return visitor.visitVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def variableDeclaration(self):

        localctx = AingalLangParser.VariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_variableDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 122
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==7:
                self.state = 121
                self.match(AingalLangParser.SET)


            self.state = 126
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.state = 124
                self.scopedIdentifier()
                pass

            elif la_ == 2:
                self.state = 125
                self.leftHandSide()
                pass


            self.state = 128
            self.match(AingalLangParser.TO)
            self.state = 129
            self.expression()
            self.state = 131
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 8935141660703064064) != 0):
                self.state = 130
                self.typeAnnotation()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def scopedIdentifier(self):
            return self.getTypedRuleContext(AingalLangParser.ScopedIdentifierContext,0)


        def TO(self):
            return self.getToken(AingalLangParser.TO, 0)

        def expression(self):
            return self.getTypedRuleContext(AingalLangParser.ExpressionContext,0)


        def getRuleIndex(self):
            return AingalLangParser.RULE_assignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignment" ):
                listener.enterAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignment" ):
                listener.exitAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignment" ):
                return visitor.visitAssignment(self)
            else:
                return visitor.visitChildren(self)




    def assignment(self):

        localctx = AingalLangParser.AssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_assignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 133
            self.scopedIdentifier()
            self.state = 134
            self.match(AingalLangParser.TO)
            self.state = 135
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatrixExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def matrixAtom(self):
            return self.getTypedRuleContext(AingalLangParser.MatrixAtomContext,0)


        def INVERT_MATRIX(self):
            return self.getToken(AingalLangParser.INVERT_MATRIX, 0)

        def TRANSPOSITION(self):
            return self.getToken(AingalLangParser.TRANSPOSITION, 0)

        def getRuleIndex(self):
            return AingalLangParser.RULE_matrixExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatrixExpression" ):
                listener.enterMatrixExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatrixExpression" ):
                listener.exitMatrixExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatrixExpression" ):
                return visitor.visitMatrixExpression(self)
            else:
                return visitor.visitChildren(self)




    def matrixExpression(self):

        localctx = AingalLangParser.MatrixExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_matrixExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 138
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==21:
                self.state = 137
                self.match(AingalLangParser.INVERT_MATRIX)


            self.state = 140
            self.matrixAtom()
            self.state = 142
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==22:
                self.state = 141
                self.match(AingalLangParser.TRANSPOSITION)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatrixAtomContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(AingalLangParser.IDENTIFIER, 0)

        def matrixConstruction(self):
            return self.getTypedRuleContext(AingalLangParser.MatrixConstructionContext,0)


        def getRuleIndex(self):
            return AingalLangParser.RULE_matrixAtom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatrixAtom" ):
                listener.enterMatrixAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatrixAtom" ):
                listener.exitMatrixAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatrixAtom" ):
                return visitor.visitMatrixAtom(self)
            else:
                return visitor.visitChildren(self)




    def matrixAtom(self):

        localctx = AingalLangParser.MatrixAtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_matrixAtom)
        try:
            self.state = 146
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [71]:
                self.enterOuterAlt(localctx, 1)
                self.state = 144
                self.match(AingalLangParser.IDENTIFIER)
                pass
            elif token in [50]:
                self.enterOuterAlt(localctx, 2)
                self.state = 145
                self.matrixConstruction()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatrixConstructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACK(self):
            return self.getToken(AingalLangParser.LBRACK, 0)

        def row(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.RowContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.RowContext,i)


        def RBRACK(self):
            return self.getToken(AingalLangParser.RBRACK, 0)

        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.SEMICOLON)
            else:
                return self.getToken(AingalLangParser.SEMICOLON, i)

        def getRuleIndex(self):
            return AingalLangParser.RULE_matrixConstruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatrixConstruction" ):
                listener.enterMatrixConstruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatrixConstruction" ):
                listener.exitMatrixConstruction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatrixConstruction" ):
                return visitor.visitMatrixConstruction(self)
            else:
                return visitor.visitChildren(self)




    def matrixConstruction(self):

        localctx = AingalLangParser.MatrixConstructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_matrixConstruction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 148
            self.match(AingalLangParser.LBRACK)
            self.state = 149
            self.row()
            self.state = 154
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==45:
                self.state = 150
                self.match(AingalLangParser.SEMICOLON)
                self.state = 151
                self.row()
                self.state = 156
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 157
            self.match(AingalLangParser.RBRACK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RowContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def value(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.ValueContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.ValueContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.COMMA)
            else:
                return self.getToken(AingalLangParser.COMMA, i)

        def getRuleIndex(self):
            return AingalLangParser.RULE_row

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRow" ):
                listener.enterRow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRow" ):
                listener.exitRow(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRow" ):
                return visitor.visitRow(self)
            else:
                return visitor.visitChildren(self)




    def row(self):

        localctx = AingalLangParser.RowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_row)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 159
            self.value()
            self.state = 164
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==46:
                self.state = 160
                self.match(AingalLangParser.COMMA)
                self.state = 161
                self.value()
                self.state = 166
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(AingalLangParser.NUMBER, 0)

        def IDENTIFIER(self):
            return self.getToken(AingalLangParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return AingalLangParser.RULE_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValue" ):
                listener.enterValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValue" ):
                listener.exitValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValue" ):
                return visitor.visitValue(self)
            else:
                return visitor.visitChildren(self)




    def value(self):

        localctx = AingalLangParser.ValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_value)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 167
            _la = self._input.LA(1)
            if not(_la==56 or _la==71):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.STRING)
            else:
                return self.getToken(AingalLangParser.STRING, i)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.IDENTIFIER)
            else:
                return self.getToken(AingalLangParser.IDENTIFIER, i)

        def PLUS(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.PLUS)
            else:
                return self.getToken(AingalLangParser.PLUS, i)

        def getRuleIndex(self):
            return AingalLangParser.RULE_stringExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringExpression" ):
                listener.enterStringExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringExpression" ):
                listener.exitStringExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringExpression" ):
                return visitor.visitStringExpression(self)
            else:
                return visitor.visitChildren(self)




    def stringExpression(self):

        localctx = AingalLangParser.StringExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_stringExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 169
            _la = self._input.LA(1)
            if not(_la==57 or _la==71):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 174
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==25:
                self.state = 170
                self.match(AingalLangParser.PLUS)
                self.state = 171
                _la = self._input.LA(1)
                if not(_la==57 or _la==71):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 176
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionCall(self):
            return self.getTypedRuleContext(AingalLangParser.FunctionCallContext,0)


        def builtInFunctions(self):
            return self.getTypedRuleContext(AingalLangParser.BuiltInFunctionsContext,0)


        def numExpression(self):
            return self.getTypedRuleContext(AingalLangParser.NumExpressionContext,0)


        def boolExpression(self):
            return self.getTypedRuleContext(AingalLangParser.BoolExpressionContext,0)


        def matrixExpression(self):
            return self.getTypedRuleContext(AingalLangParser.MatrixExpressionContext,0)


        def stringExpression(self):
            return self.getTypedRuleContext(AingalLangParser.StringExpressionContext,0)


        def NUMBER(self):
            return self.getToken(AingalLangParser.NUMBER, 0)

        def STRING(self):
            return self.getToken(AingalLangParser.STRING, 0)

        def scopedIdentifier(self):
            return self.getTypedRuleContext(AingalLangParser.ScopedIdentifierContext,0)


        def IDENTIFIER(self):
            return self.getToken(AingalLangParser.IDENTIFIER, 0)

        def LPAREN(self):
            return self.getToken(AingalLangParser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(AingalLangParser.ExpressionContext,0)


        def RPAREN(self):
            return self.getToken(AingalLangParser.RPAREN, 0)

        def getRuleIndex(self):
            return AingalLangParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = AingalLangParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_expression)
        try:
            self.state = 191
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 177
                self.functionCall()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 178
                self.builtInFunctions()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 179
                self.numExpression(0)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 180
                self.boolExpression()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 181
                self.matrixExpression()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 182
                self.stringExpression()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 183
                self.match(AingalLangParser.NUMBER)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 184
                self.match(AingalLangParser.STRING)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 185
                self.scopedIdentifier()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 186
                self.match(AingalLangParser.IDENTIFIER)
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 187
                self.match(AingalLangParser.LPAREN)
                self.state = 188
                self.expression()
                self.state = 189
                self.match(AingalLangParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopedIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(AingalLangParser.IDENTIFIER, 0)

        def PARENT_SCOPE(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.PARENT_SCOPE)
            else:
                return self.getToken(AingalLangParser.PARENT_SCOPE, i)

        def DCOLON(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.DCOLON)
            else:
                return self.getToken(AingalLangParser.DCOLON, i)

        def getRuleIndex(self):
            return AingalLangParser.RULE_scopedIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScopedIdentifier" ):
                listener.enterScopedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScopedIdentifier" ):
                listener.exitScopedIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitScopedIdentifier" ):
                return visitor.visitScopedIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def scopedIdentifier(self):

        localctx = AingalLangParser.ScopedIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_scopedIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 195 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 193
                self.match(AingalLangParser.PARENT_SCOPE)
                self.state = 194
                self.match(AingalLangParser.DCOLON)
                self.state = 197 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==23):
                    break

            self.state = 199
            self.match(AingalLangParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeAnnotationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE_STRING(self):
            return self.getToken(AingalLangParser.TYPE_STRING, 0)

        def TYPE_INT(self):
            return self.getToken(AingalLangParser.TYPE_INT, 0)

        def TYPE_FLOAT(self):
            return self.getToken(AingalLangParser.TYPE_FLOAT, 0)

        def TYPE_BOOL(self):
            return self.getToken(AingalLangParser.TYPE_BOOL, 0)

        def TYPE_MATRIX(self):
            return self.getToken(AingalLangParser.TYPE_MATRIX, 0)

        def getRuleIndex(self):
            return AingalLangParser.RULE_typeAnnotation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeAnnotation" ):
                listener.enterTypeAnnotation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeAnnotation" ):
                listener.exitTypeAnnotation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeAnnotation" ):
                return visitor.visitTypeAnnotation(self)
            else:
                return visitor.visitChildren(self)




    def typeAnnotation(self):

        localctx = AingalLangParser.TypeAnnotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_typeAnnotation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 8935141660703064064) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFINE_FUNCTION(self):
            return self.getToken(AingalLangParser.DEFINE_FUNCTION, 0)

        def IDENTIFIER(self):
            return self.getToken(AingalLangParser.IDENTIFIER, 0)

        def LPAREN(self):
            return self.getToken(AingalLangParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(AingalLangParser.RPAREN, 0)

        def blockStatement(self):
            return self.getTypedRuleContext(AingalLangParser.BlockStatementContext,0)


        def END_FUNCTION(self):
            return self.getToken(AingalLangParser.END_FUNCTION, 0)

        def parameter(self):
            return self.getTypedRuleContext(AingalLangParser.ParameterContext,0)


        def getRuleIndex(self):
            return AingalLangParser.RULE_functionDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionDeclaration" ):
                listener.enterFunctionDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionDeclaration" ):
                listener.exitFunctionDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionDeclaration" ):
                return visitor.visitFunctionDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def functionDeclaration(self):

        localctx = AingalLangParser.FunctionDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_functionDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 203
            self.match(AingalLangParser.DEFINE_FUNCTION)
            self.state = 204
            self.match(AingalLangParser.IDENTIFIER)
            self.state = 205
            self.match(AingalLangParser.LPAREN)
            self.state = 207
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==71:
                self.state = 206
                self.parameter()


            self.state = 209
            self.match(AingalLangParser.RPAREN)
            self.state = 210
            self.blockStatement()
            self.state = 211
            self.match(AingalLangParser.END_FUNCTION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typedParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.TypedParameterContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.TypedParameterContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.COMMA)
            else:
                return self.getToken(AingalLangParser.COMMA, i)

        def getRuleIndex(self):
            return AingalLangParser.RULE_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter" ):
                listener.enterParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter" ):
                listener.exitParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter" ):
                return visitor.visitParameter(self)
            else:
                return visitor.visitChildren(self)




    def parameter(self):

        localctx = AingalLangParser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_parameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213
            self.typedParameter()
            self.state = 218
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==46:
                self.state = 214
                self.match(AingalLangParser.COMMA)
                self.state = 215
                self.typedParameter()
                self.state = 220
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypedParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(AingalLangParser.IDENTIFIER, 0)

        def typeAnnotation(self):
            return self.getTypedRuleContext(AingalLangParser.TypeAnnotationContext,0)


        def getRuleIndex(self):
            return AingalLangParser.RULE_typedParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypedParameter" ):
                listener.enterTypedParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypedParameter" ):
                listener.exitTypedParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypedParameter" ):
                return visitor.visitTypedParameter(self)
            else:
                return visitor.visitChildren(self)




    def typedParameter(self):

        localctx = AingalLangParser.TypedParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_typedParameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 221
            self.match(AingalLangParser.IDENTIFIER)
            self.state = 223
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 8935141660703064064) != 0):
                self.state = 222
                self.typeAnnotation()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(AingalLangParser.RETURN, 0)

        def expression(self):
            return self.getTypedRuleContext(AingalLangParser.ExpressionContext,0)


        def getRuleIndex(self):
            return AingalLangParser.RULE_returnStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnStatement" ):
                listener.enterReturnStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnStatement" ):
                listener.exitReturnStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnStatement" ):
                return visitor.visitReturnStatement(self)
            else:
                return visitor.visitChildren(self)




    def returnStatement(self):

        localctx = AingalLangParser.ReturnStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_returnStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 225
            self.match(AingalLangParser.RETURN)
            self.state = 226
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(AingalLangParser.IDENTIFIER, 0)

        def LPAREN(self):
            return self.getToken(AingalLangParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(AingalLangParser.RPAREN, 0)

        def CALL(self):
            return self.getToken(AingalLangParser.CALL, 0)

        def argumentList(self):
            return self.getTypedRuleContext(AingalLangParser.ArgumentListContext,0)


        def getRuleIndex(self):
            return AingalLangParser.RULE_functionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCall" ):
                listener.enterFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCall" ):
                listener.exitFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCall" ):
                return visitor.visitFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def functionCall(self):

        localctx = AingalLangParser.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_functionCall)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 229
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==6:
                self.state = 228
                self.match(AingalLangParser.CALL)


            self.state = 231
            self.match(AingalLangParser.IDENTIFIER)
            self.state = 232
            self.match(AingalLangParser.LPAREN)
            self.state = 234
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 235330672827301952) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 255) != 0):
                self.state = 233
                self.argumentList()


            self.state = 236
            self.match(AingalLangParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.ExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.COMMA)
            else:
                return self.getToken(AingalLangParser.COMMA, i)

        def getRuleIndex(self):
            return AingalLangParser.RULE_argumentList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgumentList" ):
                listener.enterArgumentList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgumentList" ):
                listener.exitArgumentList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgumentList" ):
                return visitor.visitArgumentList(self)
            else:
                return visitor.visitChildren(self)




    def argumentList(self):

        localctx = AingalLangParser.ArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_argumentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 238
            self.expression()
            self.state = 243
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==46:
                self.state = 239
                self.match(AingalLangParser.COMMA)
                self.state = 240
                self.expression()
                self.state = 245
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BuiltInFunctionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POWER_FUNC(self):
            return self.getToken(AingalLangParser.POWER_FUNC, 0)

        def LPAREN(self):
            return self.getToken(AingalLangParser.LPAREN, 0)

        def numExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.NumExpressionContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.NumExpressionContext,i)


        def COMMA(self):
            return self.getToken(AingalLangParser.COMMA, 0)

        def RPAREN(self):
            return self.getToken(AingalLangParser.RPAREN, 0)

        def SIN_FUNC(self):
            return self.getToken(AingalLangParser.SIN_FUNC, 0)

        def COS_FUNC(self):
            return self.getToken(AingalLangParser.COS_FUNC, 0)

        def TAN_FUNC(self):
            return self.getToken(AingalLangParser.TAN_FUNC, 0)

        def CTAN_FUNC(self):
            return self.getToken(AingalLangParser.CTAN_FUNC, 0)

        def getRuleIndex(self):
            return AingalLangParser.RULE_builtInFunctions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBuiltInFunctions" ):
                listener.enterBuiltInFunctions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBuiltInFunctions" ):
                listener.exitBuiltInFunctions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBuiltInFunctions" ):
                return visitor.visitBuiltInFunctions(self)
            else:
                return visitor.visitChildren(self)




    def builtInFunctions(self):

        localctx = AingalLangParser.BuiltInFunctionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_builtInFunctions)
        self._la = 0 # Token type
        try:
            self.state = 258
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [66]:
                self.enterOuterAlt(localctx, 1)
                self.state = 246
                self.match(AingalLangParser.POWER_FUNC)
                self.state = 247
                self.match(AingalLangParser.LPAREN)
                self.state = 248
                self.numExpression(0)
                self.state = 249
                self.match(AingalLangParser.COMMA)
                self.state = 250
                self.numExpression(0)
                self.state = 251
                self.match(AingalLangParser.RPAREN)
                pass
            elif token in [67, 68, 69, 70]:
                self.enterOuterAlt(localctx, 2)
                self.state = 253
                _la = self._input.LA(1)
                if not(((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & 15) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 254
                self.match(AingalLangParser.LPAREN)
                self.state = 255
                self.numExpression(0)
                self.state = 256
                self.match(AingalLangParser.RPAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(AingalLangParser.IF, 0)

        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.LPAREN)
            else:
                return self.getToken(AingalLangParser.LPAREN, i)

        def boolExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.BoolExpressionContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.BoolExpressionContext,i)


        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.RPAREN)
            else:
                return self.getToken(AingalLangParser.RPAREN, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.StatementContext,i)


        def blockStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.BlockStatementContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.BlockStatementContext,i)


        def ELSE_IF(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.ELSE_IF)
            else:
                return self.getToken(AingalLangParser.ELSE_IF, i)

        def ELSE(self):
            return self.getToken(AingalLangParser.ELSE, 0)

        def getRuleIndex(self):
            return AingalLangParser.RULE_ifStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfStatement" ):
                listener.enterIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfStatement" ):
                listener.exitIfStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfStatement" ):
                return visitor.visitIfStatement(self)
            else:
                return visitor.visitChildren(self)




    def ifStatement(self):

        localctx = AingalLangParser.IfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_ifStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 260
            self.match(AingalLangParser.IF)
            self.state = 261
            self.match(AingalLangParser.LPAREN)
            self.state = 262
            self.boolExpression()
            self.state = 263
            self.match(AingalLangParser.RPAREN)
            self.state = 266
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                self.state = 264
                self.statement()
                pass

            elif la_ == 2:
                self.state = 265
                self.blockStatement()
                pass


            self.state = 278
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,23,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 268
                    self.match(AingalLangParser.ELSE_IF)
                    self.state = 269
                    self.match(AingalLangParser.LPAREN)
                    self.state = 270
                    self.boolExpression()
                    self.state = 271
                    self.match(AingalLangParser.RPAREN)
                    self.state = 274
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
                    if la_ == 1:
                        self.state = 272
                        self.statement()
                        pass

                    elif la_ == 2:
                        self.state = 273
                        self.blockStatement()
                        pass

             
                self.state = 280
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,23,self._ctx)

            self.state = 286
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                self.state = 281
                self.match(AingalLangParser.ELSE)
                self.state = 284
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
                if la_ == 1:
                    self.state = 282
                    self.statement()
                    pass

                elif la_ == 2:
                    self.state = 283
                    self.blockStatement()
                    pass




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopIfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(AingalLangParser.IF, 0)

        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.LPAREN)
            else:
                return self.getToken(AingalLangParser.LPAREN, i)

        def boolExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.BoolExpressionContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.BoolExpressionContext,i)


        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.RPAREN)
            else:
                return self.getToken(AingalLangParser.RPAREN, i)

        def LBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.LBRACE)
            else:
                return self.getToken(AingalLangParser.LBRACE, i)

        def RBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.RBRACE)
            else:
                return self.getToken(AingalLangParser.RBRACE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.StatementContext,i)


        def ELSE_IF(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.ELSE_IF)
            else:
                return self.getToken(AingalLangParser.ELSE_IF, i)

        def ELSE(self):
            return self.getToken(AingalLangParser.ELSE, 0)

        def loopStatements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.LoopStatementsContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.LoopStatementsContext,i)


        def getRuleIndex(self):
            return AingalLangParser.RULE_loopIfStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopIfStatement" ):
                listener.enterLoopIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopIfStatement" ):
                listener.exitLoopIfStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopIfStatement" ):
                return visitor.visitLoopIfStatement(self)
            else:
                return visitor.visitChildren(self)




    def loopIfStatement(self):

        localctx = AingalLangParser.LoopIfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_loopIfStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 288
            self.match(AingalLangParser.IF)
            self.state = 289
            self.match(AingalLangParser.LPAREN)
            self.state = 290
            self.boolExpression()
            self.state = 291
            self.match(AingalLangParser.RPAREN)
            self.state = 301
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                self.state = 292
                self.match(AingalLangParser.LBRACE)
                self.state = 294 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 293
                    self.loopStatements()
                    self.state = 296 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 4503599636563624) != 0) or _la==71):
                        break

                self.state = 298
                self.match(AingalLangParser.RBRACE)
                pass

            elif la_ == 2:
                self.state = 300
                self.statement()
                pass


            self.state = 320
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 303
                self.match(AingalLangParser.ELSE_IF)
                self.state = 304
                self.match(AingalLangParser.LPAREN)
                self.state = 305
                self.boolExpression()
                self.state = 306
                self.match(AingalLangParser.RPAREN)
                self.state = 316
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
                if la_ == 1:
                    self.state = 307
                    self.match(AingalLangParser.LBRACE)
                    self.state = 309 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 308
                        self.loopStatements()
                        self.state = 311 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 4503599636563624) != 0) or _la==71):
                            break

                    self.state = 313
                    self.match(AingalLangParser.RBRACE)
                    pass

                elif la_ == 2:
                    self.state = 315
                    self.statement()
                    pass


                self.state = 322
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 335
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 323
                self.match(AingalLangParser.ELSE)
                self.state = 333
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
                if la_ == 1:
                    self.state = 324
                    self.match(AingalLangParser.LBRACE)
                    self.state = 326 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 325
                        self.loopStatements()
                        self.state = 328 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 4503599636563624) != 0) or _la==71):
                            break

                    self.state = 330
                    self.match(AingalLangParser.RBRACE)
                    pass

                elif la_ == 2:
                    self.state = 332
                    self.statement()
                    pass




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def forLoop(self):
            return self.getTypedRuleContext(AingalLangParser.ForLoopContext,0)


        def whileLoop(self):
            return self.getTypedRuleContext(AingalLangParser.WhileLoopContext,0)


        def getRuleIndex(self):
            return AingalLangParser.RULE_loopStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopStatement" ):
                listener.enterLoopStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopStatement" ):
                listener.exitLoopStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopStatement" ):
                return visitor.visitLoopStatement(self)
            else:
                return visitor.visitChildren(self)




    def loopStatement(self):

        localctx = AingalLangParser.LoopStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_loopStatement)
        try:
            self.state = 339
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [14]:
                self.enterOuterAlt(localctx, 1)
                self.state = 337
                self.forLoop()
                pass
            elif token in [19]:
                self.enterOuterAlt(localctx, 2)
                self.state = 338
                self.whileLoop()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForLoopContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.cond = None # BoolExpressionContext

        def FOR(self):
            return self.getToken(AingalLangParser.FOR, 0)

        def LPAREN(self):
            return self.getToken(AingalLangParser.LPAREN, 0)

        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.SEMICOLON)
            else:
                return self.getToken(AingalLangParser.SEMICOLON, i)

        def forUpdate(self):
            return self.getTypedRuleContext(AingalLangParser.ForUpdateContext,0)


        def RPAREN(self):
            return self.getToken(AingalLangParser.RPAREN, 0)

        def forBody(self):
            return self.getTypedRuleContext(AingalLangParser.ForBodyContext,0)


        def boolExpression(self):
            return self.getTypedRuleContext(AingalLangParser.BoolExpressionContext,0)


        def forInit(self):
            return self.getTypedRuleContext(AingalLangParser.ForInitContext,0)


        def getRuleIndex(self):
            return AingalLangParser.RULE_forLoop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForLoop" ):
                listener.enterForLoop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForLoop" ):
                listener.exitForLoop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForLoop" ):
                return visitor.visitForLoop(self)
            else:
                return visitor.visitChildren(self)




    def forLoop(self):

        localctx = AingalLangParser.ForLoopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_forLoop)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 341
            self.match(AingalLangParser.FOR)
            self.state = 342
            self.match(AingalLangParser.LPAREN)
            self.state = 344
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==7 or _la==23 or _la==71:
                self.state = 343
                self.forInit()


            self.state = 346
            self.match(AingalLangParser.SEMICOLON)
            self.state = 347
            localctx.cond = self.boolExpression()
            self.state = 348
            self.match(AingalLangParser.SEMICOLON)
            self.state = 349
            self.forUpdate()
            self.state = 350
            self.match(AingalLangParser.RPAREN)
            self.state = 351
            self.forBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForInitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(AingalLangParser.IDENTIFIER, 0)

        def variableDeclaration(self):
            return self.getTypedRuleContext(AingalLangParser.VariableDeclarationContext,0)


        def getRuleIndex(self):
            return AingalLangParser.RULE_forInit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForInit" ):
                listener.enterForInit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForInit" ):
                listener.exitForInit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForInit" ):
                return visitor.visitForInit(self)
            else:
                return visitor.visitChildren(self)




    def forInit(self):

        localctx = AingalLangParser.ForInitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_forInit)
        try:
            self.state = 355
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 353
                self.match(AingalLangParser.IDENTIFIER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 354
                self.variableDeclaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForUpdateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclaration(self):
            return self.getTypedRuleContext(AingalLangParser.VariableDeclarationContext,0)


        def reassignment(self):
            return self.getTypedRuleContext(AingalLangParser.ReassignmentContext,0)


        def operation(self):
            return self.getTypedRuleContext(AingalLangParser.OperationContext,0)


        def getRuleIndex(self):
            return AingalLangParser.RULE_forUpdate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForUpdate" ):
                listener.enterForUpdate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForUpdate" ):
                listener.exitForUpdate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForUpdate" ):
                return visitor.visitForUpdate(self)
            else:
                return visitor.visitChildren(self)




    def forUpdate(self):

        localctx = AingalLangParser.ForUpdateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_forUpdate)
        try:
            self.state = 360
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 357
                self.variableDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 358
                self.reassignment()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 359
                self.operation()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(AingalLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(AingalLangParser.RBRACE, 0)

        def loopStatements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.LoopStatementsContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.LoopStatementsContext,i)


        def statement(self):
            return self.getTypedRuleContext(AingalLangParser.StatementContext,0)


        def getRuleIndex(self):
            return AingalLangParser.RULE_forBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForBody" ):
                listener.enterForBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForBody" ):
                listener.exitForBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForBody" ):
                return visitor.visitForBody(self)
            else:
                return visitor.visitChildren(self)




    def forBody(self):

        localctx = AingalLangParser.ForBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_forBody)
        self._la = 0 # Token type
        try:
            self.state = 371
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 362
                self.match(AingalLangParser.LBRACE)
                self.state = 364 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 363
                    self.loopStatements()
                    self.state = 366 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 4503599636563624) != 0) or _la==71):
                        break

                self.state = 368
                self.match(AingalLangParser.RBRACE)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 370
                self.statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhileLoopContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(AingalLangParser.WHILE, 0)

        def LPAREN(self):
            return self.getToken(AingalLangParser.LPAREN, 0)

        def boolExpression(self):
            return self.getTypedRuleContext(AingalLangParser.BoolExpressionContext,0)


        def RPAREN(self):
            return self.getToken(AingalLangParser.RPAREN, 0)

        def LBRACE(self):
            return self.getToken(AingalLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(AingalLangParser.RBRACE, 0)

        def statement(self):
            return self.getTypedRuleContext(AingalLangParser.StatementContext,0)


        def loopStatements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.LoopStatementsContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.LoopStatementsContext,i)


        def getRuleIndex(self):
            return AingalLangParser.RULE_whileLoop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileLoop" ):
                listener.enterWhileLoop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileLoop" ):
                listener.exitWhileLoop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhileLoop" ):
                return visitor.visitWhileLoop(self)
            else:
                return visitor.visitChildren(self)




    def whileLoop(self):

        localctx = AingalLangParser.WhileLoopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_whileLoop)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 373
            self.match(AingalLangParser.WHILE)
            self.state = 374
            self.match(AingalLangParser.LPAREN)
            self.state = 375
            self.boolExpression()
            self.state = 376
            self.match(AingalLangParser.RPAREN)
            self.state = 386
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
            if la_ == 1:
                self.state = 377
                self.match(AingalLangParser.LBRACE)
                self.state = 379 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 378
                    self.loopStatements()
                    self.state = 381 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 4503599636563624) != 0) or _la==71):
                        break

                self.state = 383
                self.match(AingalLangParser.RBRACE)
                pass

            elif la_ == 2:
                self.state = 385
                self.statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DisplayStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISPLAY(self):
            return self.getToken(AingalLangParser.DISPLAY, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.ExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.COMMA)
            else:
                return self.getToken(AingalLangParser.COMMA, i)

        def getRuleIndex(self):
            return AingalLangParser.RULE_displayStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDisplayStatement" ):
                listener.enterDisplayStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDisplayStatement" ):
                listener.exitDisplayStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDisplayStatement" ):
                return visitor.visitDisplayStatement(self)
            else:
                return visitor.visitChildren(self)




    def displayStatement(self):

        localctx = AingalLangParser.DisplayStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_displayStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 388
            self.match(AingalLangParser.DISPLAY)
            self.state = 389
            self.expression()
            self.state = 394
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==46:
                self.state = 390
                self.match(AingalLangParser.COMMA)
                self.state = 391
                self.expression()
                self.state = 396
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(AingalLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(AingalLangParser.RBRACE, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.StatementContext,i)


        def getRuleIndex(self):
            return AingalLangParser.RULE_blockStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlockStatement" ):
                listener.enterBlockStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlockStatement" ):
                listener.exitBlockStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlockStatement" ):
                return visitor.visitBlockStatement(self)
            else:
                return visitor.visitChildren(self)




    def blockStatement(self):

        localctx = AingalLangParser.BlockStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_blockStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 397
            self.match(AingalLangParser.LBRACE)
            self.state = 401
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 4503599636301544) != 0) or _la==71:
                self.state = 398
                self.statement()
                self.state = 403
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 404
            self.match(AingalLangParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self):
            return self.getTypedRuleContext(AingalLangParser.TermContext,0)


        def numExpression(self):
            return self.getTypedRuleContext(AingalLangParser.NumExpressionContext,0)


        def PLUS(self):
            return self.getToken(AingalLangParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(AingalLangParser.MINUS, 0)

        def getRuleIndex(self):
            return AingalLangParser.RULE_numExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumExpression" ):
                listener.enterNumExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumExpression" ):
                listener.exitNumExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumExpression" ):
                return visitor.visitNumExpression(self)
            else:
                return visitor.visitChildren(self)



    def numExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AingalLangParser.NumExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 62
        self.enterRecursionRule(localctx, 62, self.RULE_numExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 407
            self.term(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 414
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,44,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = AingalLangParser.NumExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_numExpression)
                    self.state = 409
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 410
                    _la = self._input.LA(1)
                    if not(_la==25 or _la==26):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 411
                    self.term(0) 
                self.state = 416
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,44,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class TermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def factor(self):
            return self.getTypedRuleContext(AingalLangParser.FactorContext,0)


        def term(self):
            return self.getTypedRuleContext(AingalLangParser.TermContext,0)


        def MULTIPLY(self):
            return self.getToken(AingalLangParser.MULTIPLY, 0)

        def DIVIDED_BY(self):
            return self.getToken(AingalLangParser.DIVIDED_BY, 0)

        def MODULO(self):
            return self.getToken(AingalLangParser.MODULO, 0)

        def getRuleIndex(self):
            return AingalLangParser.RULE_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm" ):
                listener.enterTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm" ):
                listener.exitTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerm" ):
                return visitor.visitTerm(self)
            else:
                return visitor.visitChildren(self)



    def term(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AingalLangParser.TermContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 64
        self.enterRecursionRule(localctx, 64, self.RULE_term, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 418
            self.factor()
            self._ctx.stop = self._input.LT(-1)
            self.state = 425
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,45,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = AingalLangParser.TermContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_term)
                    self.state = 420
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 421
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 939524096) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 422
                    self.factor() 
                self.state = 427
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,45,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class FactorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AingalLangParser.RULE_factor

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class CastExpressionContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(AingalLangParser.LPAREN, 0)
        def typeAnnotation(self):
            return self.getTypedRuleContext(AingalLangParser.TypeAnnotationContext,0)

        def RPAREN(self):
            return self.getToken(AingalLangParser.RPAREN, 0)
        def factor(self):
            return self.getTypedRuleContext(AingalLangParser.FactorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCastExpression" ):
                listener.enterCastExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCastExpression" ):
                listener.exitCastExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCastExpression" ):
                return visitor.visitCastExpression(self)
            else:
                return visitor.visitChildren(self)


    class FactorFalseContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FALSE_VALUE(self):
            return self.getToken(AingalLangParser.FALSE_VALUE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorFalse" ):
                listener.enterFactorFalse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorFalse" ):
                listener.exitFactorFalse(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorFalse" ):
                return visitor.visitFactorFalse(self)
            else:
                return visitor.visitChildren(self)


    class FactorOperationContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def operation(self):
            return self.getTypedRuleContext(AingalLangParser.OperationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorOperation" ):
                listener.enterFactorOperation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorOperation" ):
                listener.exitFactorOperation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorOperation" ):
                return visitor.visitFactorOperation(self)
            else:
                return visitor.visitChildren(self)


    class UnaryPlusContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def PLUS(self):
            return self.getToken(AingalLangParser.PLUS, 0)
        def factor(self):
            return self.getTypedRuleContext(AingalLangParser.FactorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryPlus" ):
                listener.enterUnaryPlus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryPlus" ):
                listener.exitUnaryPlus(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryPlus" ):
                return visitor.visitUnaryPlus(self)
            else:
                return visitor.visitChildren(self)


    class FactorIdentifierContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IDENTIFIER(self):
            return self.getToken(AingalLangParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorIdentifier" ):
                listener.enterFactorIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorIdentifier" ):
                listener.exitFactorIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorIdentifier" ):
                return visitor.visitFactorIdentifier(self)
            else:
                return visitor.visitChildren(self)


    class FactorFunctionCallContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def functionCall(self):
            return self.getTypedRuleContext(AingalLangParser.FunctionCallContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorFunctionCall" ):
                listener.enterFactorFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorFunctionCall" ):
                listener.exitFactorFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorFunctionCall" ):
                return visitor.visitFactorFunctionCall(self)
            else:
                return visitor.visitChildren(self)


    class FactorNumberContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(AingalLangParser.NUMBER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorNumber" ):
                listener.enterFactorNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorNumber" ):
                listener.exitFactorNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorNumber" ):
                return visitor.visitFactorNumber(self)
            else:
                return visitor.visitChildren(self)


    class UnaryMinusContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MINUS(self):
            return self.getToken(AingalLangParser.MINUS, 0)
        def factor(self):
            return self.getTypedRuleContext(AingalLangParser.FactorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryMinus" ):
                listener.enterUnaryMinus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryMinus" ):
                listener.exitUnaryMinus(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryMinus" ):
                return visitor.visitUnaryMinus(self)
            else:
                return visitor.visitChildren(self)


    class FactorParensContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(AingalLangParser.LPAREN, 0)
        def numExpression(self):
            return self.getTypedRuleContext(AingalLangParser.NumExpressionContext,0)

        def RPAREN(self):
            return self.getToken(AingalLangParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorParens" ):
                listener.enterFactorParens(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorParens" ):
                listener.exitFactorParens(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorParens" ):
                return visitor.visitFactorParens(self)
            else:
                return visitor.visitChildren(self)


    class FactorscopedIdentifierContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def scopedIdentifier(self):
            return self.getTypedRuleContext(AingalLangParser.ScopedIdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorscopedIdentifier" ):
                listener.enterFactorscopedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorscopedIdentifier" ):
                listener.exitFactorscopedIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorscopedIdentifier" ):
                return visitor.visitFactorscopedIdentifier(self)
            else:
                return visitor.visitChildren(self)


    class FactorStringContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING(self):
            return self.getToken(AingalLangParser.STRING, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorString" ):
                listener.enterFactorString(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorString" ):
                listener.exitFactorString(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorString" ):
                return visitor.visitFactorString(self)
            else:
                return visitor.visitChildren(self)


    class FactorTrueContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TRUE_VALUE(self):
            return self.getToken(AingalLangParser.TRUE_VALUE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorTrue" ):
                listener.enterFactorTrue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorTrue" ):
                listener.exitFactorTrue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorTrue" ):
                return visitor.visitFactorTrue(self)
            else:
                return visitor.visitChildren(self)



    def factor(self):

        localctx = AingalLangParser.FactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_factor)
        try:
            self.state = 449
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
            if la_ == 1:
                localctx = AingalLangParser.UnaryPlusContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 428
                self.match(AingalLangParser.PLUS)
                self.state = 429
                self.factor()
                pass

            elif la_ == 2:
                localctx = AingalLangParser.UnaryMinusContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 430
                self.match(AingalLangParser.MINUS)
                self.state = 431
                self.factor()
                pass

            elif la_ == 3:
                localctx = AingalLangParser.FactorFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 432
                self.functionCall()
                pass

            elif la_ == 4:
                localctx = AingalLangParser.FactorNumberContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 433
                self.match(AingalLangParser.NUMBER)
                pass

            elif la_ == 5:
                localctx = AingalLangParser.FactorscopedIdentifierContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 434
                self.scopedIdentifier()
                pass

            elif la_ == 6:
                localctx = AingalLangParser.FactorIdentifierContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 435
                self.match(AingalLangParser.IDENTIFIER)
                pass

            elif la_ == 7:
                localctx = AingalLangParser.FactorStringContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 436
                self.match(AingalLangParser.STRING)
                pass

            elif la_ == 8:
                localctx = AingalLangParser.FactorOperationContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 437
                self.operation()
                pass

            elif la_ == 9:
                localctx = AingalLangParser.FactorParensContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 438
                self.match(AingalLangParser.LPAREN)
                self.state = 439
                self.numExpression(0)
                self.state = 440
                self.match(AingalLangParser.RPAREN)
                pass

            elif la_ == 10:
                localctx = AingalLangParser.CastExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 442
                self.match(AingalLangParser.LPAREN)
                self.state = 443
                self.typeAnnotation()
                self.state = 444
                self.match(AingalLangParser.RPAREN)
                self.state = 445
                self.factor()
                pass

            elif la_ == 11:
                localctx = AingalLangParser.FactorTrueContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 447
                self.match(AingalLangParser.TRUE_VALUE)
                pass

            elif la_ == 12:
                localctx = AingalLangParser.FactorFalseContext(self, localctx)
                self.enterOuterAlt(localctx, 12)
                self.state = 448
                self.match(AingalLangParser.FALSE_VALUE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(AingalLangParser.IDENTIFIER, 0)

        def INCREMENT(self):
            return self.getToken(AingalLangParser.INCREMENT, 0)

        def DECREMENT(self):
            return self.getToken(AingalLangParser.DECREMENT, 0)

        def SEMICOLON(self):
            return self.getToken(AingalLangParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return AingalLangParser.RULE_operation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperation" ):
                listener.enterOperation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperation" ):
                listener.exitOperation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperation" ):
                return visitor.visitOperation(self)
            else:
                return visitor.visitChildren(self)




    def operation(self):

        localctx = AingalLangParser.OperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_operation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 451
            self.match(AingalLangParser.IDENTIFIER)
            self.state = 452
            _la = self._input.LA(1)
            if not(_la==37 or _la==38):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 454
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
            if la_ == 1:
                self.state = 453
                self.match(AingalLangParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LeftHandSideContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(AingalLangParser.IDENTIFIER, 0)

        def scopedIdentifier(self):
            return self.getTypedRuleContext(AingalLangParser.ScopedIdentifierContext,0)


        def getRuleIndex(self):
            return AingalLangParser.RULE_leftHandSide

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLeftHandSide" ):
                listener.enterLeftHandSide(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLeftHandSide" ):
                listener.exitLeftHandSide(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLeftHandSide" ):
                return visitor.visitLeftHandSide(self)
            else:
                return visitor.visitChildren(self)




    def leftHandSide(self):

        localctx = AingalLangParser.LeftHandSideContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_leftHandSide)
        try:
            self.state = 458
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [71]:
                self.enterOuterAlt(localctx, 1)
                self.state = 456
                self.match(AingalLangParser.IDENTIFIER)
                pass
            elif token in [23]:
                self.enterOuterAlt(localctx, 2)
                self.state = 457
                self.scopedIdentifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReassignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def scopedIdentifier(self):
            return self.getTypedRuleContext(AingalLangParser.ScopedIdentifierContext,0)


        def leftHandSide(self):
            return self.getTypedRuleContext(AingalLangParser.LeftHandSideContext,0)


        def expression(self):
            return self.getTypedRuleContext(AingalLangParser.ExpressionContext,0)


        def ADD_TO(self):
            return self.getToken(AingalLangParser.ADD_TO, 0)

        def SUBTRACT_FROM(self):
            return self.getToken(AingalLangParser.SUBTRACT_FROM, 0)

        def TIMES(self):
            return self.getToken(AingalLangParser.TIMES, 0)

        def DIVIDE_FROM(self):
            return self.getToken(AingalLangParser.DIVIDE_FROM, 0)

        def SEMICOLON(self):
            return self.getToken(AingalLangParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return AingalLangParser.RULE_reassignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReassignment" ):
                listener.enterReassignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReassignment" ):
                listener.exitReassignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReassignment" ):
                return visitor.visitReassignment(self)
            else:
                return visitor.visitChildren(self)




    def reassignment(self):

        localctx = AingalLangParser.ReassignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_reassignment)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 462
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
            if la_ == 1:
                self.state = 460
                self.scopedIdentifier()
                pass

            elif la_ == 2:
                self.state = 461
                self.leftHandSide()
                pass


            self.state = 464
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1752346656768) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 465
            self.expression()
            self.state = 468
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==45:
                self.state = 467
                self.match(AingalLangParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def boolOrExpression(self):
            return self.getTypedRuleContext(AingalLangParser.BoolOrExpressionContext,0)


        def getRuleIndex(self):
            return AingalLangParser.RULE_boolExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolExpression" ):
                listener.enterBoolExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolExpression" ):
                listener.exitBoolExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolExpression" ):
                return visitor.visitBoolExpression(self)
            else:
                return visitor.visitChildren(self)




    def boolExpression(self):

        localctx = AingalLangParser.BoolExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_boolExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 470
            self.boolOrExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolOrExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AingalLangParser.RULE_boolOrExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LogicOrContext(BoolOrExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.BoolOrExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def boolAndExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.BoolAndExpressionContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.BoolAndExpressionContext,i)

        def OR(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.OR)
            else:
                return self.getToken(AingalLangParser.OR, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicOr" ):
                listener.enterLogicOr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicOr" ):
                listener.exitLogicOr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicOr" ):
                return visitor.visitLogicOr(self)
            else:
                return visitor.visitChildren(self)



    def boolOrExpression(self):

        localctx = AingalLangParser.BoolOrExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_boolOrExpression)
        self._la = 0 # Token type
        try:
            localctx = AingalLangParser.LogicOrContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 472
            self.boolAndExpression()
            self.state = 477
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==43:
                self.state = 473
                self.match(AingalLangParser.OR)
                self.state = 474
                self.boolAndExpression()
                self.state = 479
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolAndExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AingalLangParser.RULE_boolAndExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LogicAndContext(BoolAndExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.BoolAndExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def boolNotExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.BoolNotExpressionContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.BoolNotExpressionContext,i)

        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(AingalLangParser.AND)
            else:
                return self.getToken(AingalLangParser.AND, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicAnd" ):
                listener.enterLogicAnd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicAnd" ):
                listener.exitLogicAnd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicAnd" ):
                return visitor.visitLogicAnd(self)
            else:
                return visitor.visitChildren(self)



    def boolAndExpression(self):

        localctx = AingalLangParser.BoolAndExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_boolAndExpression)
        self._la = 0 # Token type
        try:
            localctx = AingalLangParser.LogicAndContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 480
            self.boolNotExpression()
            self.state = 485
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==42:
                self.state = 481
                self.match(AingalLangParser.AND)
                self.state = 482
                self.boolNotExpression()
                self.state = 487
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolNotExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AingalLangParser.RULE_boolNotExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LogicPrimaryWrapContext(BoolNotExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.BoolNotExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def boolPrimary(self):
            return self.getTypedRuleContext(AingalLangParser.BoolPrimaryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicPrimaryWrap" ):
                listener.enterLogicPrimaryWrap(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicPrimaryWrap" ):
                listener.exitLogicPrimaryWrap(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicPrimaryWrap" ):
                return visitor.visitLogicPrimaryWrap(self)
            else:
                return visitor.visitChildren(self)


    class LogicNotContext(BoolNotExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.BoolNotExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NOT(self):
            return self.getToken(AingalLangParser.NOT, 0)
        def boolNotExpression(self):
            return self.getTypedRuleContext(AingalLangParser.BoolNotExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicNot" ):
                listener.enterLogicNot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicNot" ):
                listener.exitLogicNot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicNot" ):
                return visitor.visitLogicNot(self)
            else:
                return visitor.visitChildren(self)



    def boolNotExpression(self):

        localctx = AingalLangParser.BoolNotExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_boolNotExpression)
        try:
            self.state = 491
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [44]:
                localctx = AingalLangParser.LogicNotContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 488
                self.match(AingalLangParser.NOT)
                self.state = 489
                self.boolNotExpression()
                pass
            elif token in [6, 21, 23, 25, 26, 50, 54, 56, 57, 64, 65, 71]:
                localctx = AingalLangParser.LogicPrimaryWrapContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 490
                self.boolPrimary()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolPrimaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AingalLangParser.RULE_boolPrimary

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class StringComparisonContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def stringExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.StringExpressionContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.StringExpressionContext,i)

        def EQUALS(self):
            return self.getToken(AingalLangParser.EQUALS, 0)
        def NOT_EQUALS(self):
            return self.getToken(AingalLangParser.NOT_EQUALS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringComparison" ):
                listener.enterStringComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringComparison" ):
                listener.exitStringComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringComparison" ):
                return visitor.visitStringComparison(self)
            else:
                return visitor.visitChildren(self)


    class FalseLiteralContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FALSE_VALUE(self):
            return self.getToken(AingalLangParser.FALSE_VALUE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFalseLiteral" ):
                listener.enterFalseLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFalseLiteral" ):
                listener.exitFalseLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFalseLiteral" ):
                return visitor.visitFalseLiteral(self)
            else:
                return visitor.visitChildren(self)


    class NumComparisonContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def numExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.NumExpressionContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.NumExpressionContext,i)

        def comparisonOp(self):
            return self.getTypedRuleContext(AingalLangParser.ComparisonOpContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumComparison" ):
                listener.enterNumComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumComparison" ):
                listener.exitNumComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumComparison" ):
                return visitor.visitNumComparison(self)
            else:
                return visitor.visitChildren(self)


    class LogicParenContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(AingalLangParser.LPAREN, 0)
        def boolExpression(self):
            return self.getTypedRuleContext(AingalLangParser.BoolExpressionContext,0)

        def RPAREN(self):
            return self.getToken(AingalLangParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicParen" ):
                listener.enterLogicParen(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicParen" ):
                listener.exitLogicParen(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicParen" ):
                return visitor.visitLogicParen(self)
            else:
                return visitor.visitChildren(self)


    class TrueLiteralContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TRUE_VALUE(self):
            return self.getToken(AingalLangParser.TRUE_VALUE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrueLiteral" ):
                listener.enterTrueLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrueLiteral" ):
                listener.exitTrueLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrueLiteral" ):
                return visitor.visitTrueLiteral(self)
            else:
                return visitor.visitChildren(self)


    class LogicIdentifierContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IDENTIFIER(self):
            return self.getToken(AingalLangParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicIdentifier" ):
                listener.enterLogicIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicIdentifier" ):
                listener.exitLogicIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicIdentifier" ):
                return visitor.visitLogicIdentifier(self)
            else:
                return visitor.visitChildren(self)


    class MatrixComparisonContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AingalLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def matrixExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AingalLangParser.MatrixExpressionContext)
            else:
                return self.getTypedRuleContext(AingalLangParser.MatrixExpressionContext,i)

        def EQUALS(self):
            return self.getToken(AingalLangParser.EQUALS, 0)
        def NOT_EQUALS(self):
            return self.getToken(AingalLangParser.NOT_EQUALS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatrixComparison" ):
                listener.enterMatrixComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatrixComparison" ):
                listener.exitMatrixComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatrixComparison" ):
                return visitor.visitMatrixComparison(self)
            else:
                return visitor.visitChildren(self)



    def boolPrimary(self):

        localctx = AingalLangParser.BoolPrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_boolPrimary)
        self._la = 0 # Token type
        try:
            self.state = 512
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
            if la_ == 1:
                localctx = AingalLangParser.NumComparisonContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 493
                self.numExpression(0)
                self.state = 494
                self.comparisonOp()
                self.state = 495
                self.numExpression(0)
                pass

            elif la_ == 2:
                localctx = AingalLangParser.StringComparisonContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 497
                self.stringExpression()
                self.state = 498
                _la = self._input.LA(1)
                if not(_la==30 or _la==41):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 499
                self.stringExpression()
                pass

            elif la_ == 3:
                localctx = AingalLangParser.MatrixComparisonContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 501
                self.matrixExpression()
                self.state = 502
                _la = self._input.LA(1)
                if not(_la==30 or _la==41):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 503
                self.matrixExpression()
                pass

            elif la_ == 4:
                localctx = AingalLangParser.LogicParenContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 505
                self.match(AingalLangParser.LPAREN)
                self.state = 506
                self.boolExpression()
                self.state = 507
                self.match(AingalLangParser.RPAREN)
                pass

            elif la_ == 5:
                localctx = AingalLangParser.TrueLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 509
                self.match(AingalLangParser.TRUE_VALUE)
                pass

            elif la_ == 6:
                localctx = AingalLangParser.FalseLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 510
                self.match(AingalLangParser.FALSE_VALUE)
                pass

            elif la_ == 7:
                localctx = AingalLangParser.LogicIdentifierContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 511
                self.match(AingalLangParser.IDENTIFIER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUALS(self):
            return self.getToken(AingalLangParser.EQUALS, 0)

        def NOT_EQUALS(self):
            return self.getToken(AingalLangParser.NOT_EQUALS, 0)

        def GREATER_THAN(self):
            return self.getToken(AingalLangParser.GREATER_THAN, 0)

        def LESS_THAN(self):
            return self.getToken(AingalLangParser.LESS_THAN, 0)

        def GREATER_EQUAL(self):
            return self.getToken(AingalLangParser.GREATER_EQUAL, 0)

        def LESS_EQUAL(self):
            return self.getToken(AingalLangParser.LESS_EQUAL, 0)

        def getRuleIndex(self):
            return AingalLangParser.RULE_comparisonOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonOp" ):
                listener.enterComparisonOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonOp" ):
                listener.exitComparisonOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonOp" ):
                return visitor.visitComparisonOp(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOp(self):

        localctx = AingalLangParser.ComparisonOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_comparisonOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 514
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 2232309252096) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[31] = self.numExpression_sempred
        self._predicates[32] = self.term_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def numExpression_sempred(self, localctx:NumExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 2)
         

    def term_sempred(self, localctx:TermContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 2)
         




